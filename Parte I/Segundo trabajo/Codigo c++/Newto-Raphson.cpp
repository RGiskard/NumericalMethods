#include <iostream>
#include <math.h>
#include <map>
#include <tuple> 
#include <fstream>
#include <cstdlib>
using namespace std;
typedef unsigned int int64;
typedef map<int64,tuple<double,double>> estructura;
void generarPdf(int64 iter,int64 maxIter,estructura tabla,double err);
double fun1(double x)
{
	return pow(x,3) + 3*pow(x,2) - 5;
}
double dfun1(double x)
{
	return 3*pow(x,2)+6*x;
}	
double fun2(double x)
{
	return x - exp(cos(5*x-1))*atan(pow(x,3)+2*x-4);
}
double dfun2(double x)
{
	return 1+exp(cos(5*x-1))*(5*sin(5*x-1)*atan(pow(x,3)+2*x-4)-((3*pow(x,2)+2)/(1+pow(pow(x,3)+2*x-4,2))));
}	

/*
La siguiente función es la implementacion del método newton-raphson
parámetro: f,df,p0,delta,epsilon,maxIter
f es una función
df, es la derivada de la función f
po, es la aproximacin inicial a un 0 de f
delta, es la tolerancia para p0
epsilon, es la tolerancia para los valores de la funcin
maxIter, máximo número de iteraciones.
*/
double newtonRaphsonver1(double (f)(double),double(df)(double),double p0,double delta,double epsilon,int64 maxIter)
{
	double err=0;//estimacion del error de p0
	double p1=0;//punto siguiente a tomar
	double y=f(p0);//valor de la funcion
	double relerr=0;//error relativo
	int64 i=0;
	estructura tabla;
	while(i<maxIter)
	{
		tabla[i]=tuple<double,double>(p0,f(p0));
		p1=p0-f(p0)/df(p0);
		err=fabs(p1-p0);
		relerr=2*err/(fabs(p1)+delta);
		p0=p1;
		y=f(p0);
		//tabla[p0]=y;
		if(err<delta||relerr<delta||fabs(y)<epsilon) break;
		i++;
	}	
	
	generarPdf(i,maxIter,tabla,err);
	return p0;
}	

double newtonRaphsonver2(double (f)(double),double h,double p0,double delta,double epsilon,int64 maxIter)
{
	double err=0;//estimacion del error de p0
	double p1=0;//punto siguiente a tomar
	double y=f(p0);//valor de la funcion
	double relerr=0;//error relativo
	int64 i=0;
	estructura tabla;
	while(i<maxIter)
	{
		tabla[i]=tuple<double,double>(p0,f(p0));
		p1=p0-f(p0)/((f(p0+h)-f(p0-h))/(2*h));
		err=fabs(p1-p0);
		relerr=2*err/(fabs(p1)+delta);
		p0=p1;
		y=f(p0);
		if(err<delta||relerr<delta||fabs(y)<epsilon) break;
		i++;
	}	
	
	generarPdf(i,maxIter,tabla,err);
	return p0;
}	

void generarPdf(int64 iter,int64 maxIter,estructura tabla,double err)
{
	string FileName="tableNewtonRaphson.tex";
	ofstream salida(FileName.c_str());
	salida<<"\\documentclass[a4paper,10pt]{article}"<<endl;
	salida<<"\\usepackage[utf8]{inputenc}"<<endl;
	salida<<"\\title{}"<<endl;
	salida<<"\\author{Table generated by R\\'omulo Walter Condori Bustincio}"<<endl;
	salida<<"\\begin{document}"<<endl;
	salida<<"\\maketitle"<<endl;
	salida<<"Con un total de "<<iter<<" de "<<maxIter<<" iteraciones permitidas, se obtuvo la siguiente tabla:"<<endl; 
	salida<<"\\begin{center}"<<endl;
	salida<<"\\begin{tabular}{|c|c|c|}"<<endl;
	salida<<"\\hline"<<endl;
	salida<<"Iteraci\\'on&$r$&$f(r)$\\\\"<<endl;
	salida<<"\\hline"<<endl;
	///Conseguir datos
	estructura::iterator it;
	for(it=tabla.begin();it!=tabla.end();it++)
	{
		salida<<(*it).first<<"&"<<get<0>((*it).second)<<"&"<<get<1>((*it).second)<<"\\\\"<<endl;
	}	
	it--;
	salida<<"\\hline"<<endl;
	salida<<"\\end{tabular}"<<endl;
	salida<<"\\end{center}"<<endl;
	salida<<"Donde el valor de $r$ aproximado es "<<get<0>((*it).second);
	salida<<" con un error relativo de: "<<err<<endl;
	salida<<"\\end{document}"<<endl;

	string comand="pdflatex "+FileName;
	system(comand.c_str());
}	
int main()
{
	newtonRaphsonver1(fun2,dfun2,7,0.00001,0.00001,100000);
	//newtonRaphsonver2(fun2,0.001,7,0.00001,0.00001,100000);
	//newtonRaphsonver1(fun1,dfun1,7,0.00001,0.00001,100000);
	//newtonRaphsonver2(fun1,0.001,7,0.00001,0.00001,100000);
	return 0;
}
